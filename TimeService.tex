\subsection{Сервис времени}

Для решения проблемы с рассинхронизированным временем на серверах был реализован сервис с несколькими репликами, который в ответ на последовательные запросы отдает гарантированно неубывающие значения времени.

Заведем в Cassandra ячейку GlobalTime, в которой будем хранить максимум из локальных времен запущенных реплик сервиса. Каждая реплика с некоторой периодичностью (например, раз в 500 миллисекунд) будет пытаться обновить значение времени в Cassandra, используя алгоритм TryUpdateGlobalTime

\begin{lstlisting}[language=csh,caption={Алгоритм TryUpdateGlobalTime}]
  1.  |Взять локальное значение времени, положить в переменную localTime|
  2.  |Прочитать из Cassandra ячейку GlobalTime, положить в переменную globalTime|
  3.  |Если localTime > globalTime|
  4.  	|Перезаписать ячейку GlobalTime со значением localTime с временной отметкой localTime|
\end{lstlisting}

\begin{theorem}
Значение в ячейке GlobalTime не будет убывать со временем.
\end{theorem}
\textbf{Доказательство:}
Предположим, что найдутся два последовательных момента времени $A < B$ таких, что в момент времени $A$ значение $Time_A$ в ячейке GlobalTime будет больше значения $Time_B$ в момент времени $B$. Это означает, что в промежуток времени между $А$ и $В$ было произведено обновление ячейки GlobalTime со значением меньшим, чем $Time_A$. По построению алгоритма значение времени в ячейке GlobalTime в любой момент времени совпадает с ее временной отметкой, следовательно, при изменении значения ячейки на меньшее нарушилось бы правило неуменьшения временной отметки ячейки. Следовательно, $Time_A$ не может быть больше $Time_B$.
$\Box$

Для ответа на запрос текущего времени достаточно вернуть текущее значение ячейки GlobalTime.
