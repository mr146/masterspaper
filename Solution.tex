\section{Описание алгоритмов}

Желание получить алгоритм, справедливо распределяющий доступ к разделяемому ресурсу между потоками, подводит к достаточно простой идее использования некоторого подобия очереди потоков.
Для каждого идентификатора разделяемого ресурса будем хранить в Cassandra две строки: первую будем использовать в качестве подобия очереди (далее <<очередь>>), во второй будет храниться идентификатор потока, владеющего ресурсом (далее <<основная строка>>).
При добавлении потока в очередь мы будем добавлять новую ячейку в строчку с очередью, при этом имя колонки этой ячейки будет подсчитано следующим образом:

\begin{lstlisting}[language=csh,caption={Определение имени колонки для ячейки в очереди}]
 1. |Положить в переменную currentTime строковое значение текущего времени в микросекундах|
 2. |Добавлять к значению currentTime ведущие нули до тех пор, пока его длина не станет равной 20|
 3. |Назначить именем колонки конкатенацию значений currentTime и threadId|
\end{lstlisting}

В силу того, что ячейки в строке хранятся в лексикографическом порядке имен колонок, раньше всех в очереди окажется тот поток, который будет добавлен в очередь раньше, в случае равенства времен ближе к вершине очереди окажется поток с лексикографически меньшим идентификатором.
При добавлении потока в основную строку именем колонки будем считать просто идентификатор потока.

Стоит отметить, что очередь получится не очень честной. На практике бывает сложно добиться того, чтобы время на всех серверах было одинаковым. Предположим, что у потока A время отстает от времени потока B на одну секунду. Если поток A поставит себя в очередь, а через полсекунды поток B поставит себя в очередь, то B может оказаться в ней раньше, так как время, записанное в префиксе имени колонки, окажется меньше чем у ячейки, записанной потоком В. Частично эта проблема решается реализацией сервиса времени, который по запросу будет отдавать неубывающее время. Его использование избавит нас от проблемы с несинхронным временем, однако останется еще одна проблема: операция взятия времени и записи ячейки с соответствующим именем колонки не является атомарной, и, следовательно, между этими двумя действиями может произойти задержка (например, запуск сборки мусора или передача управление другому потоку процесса). Соответственно до сих пор возможна ситуация, когда в очереди появляется поток со временем меньшим чем у всех остальных в очереди, но, во-первых, это будет происходить гораздо реже, во-вторых, если у потока возникла задержка и он встанет в очередь перед всеми другими потоками, то он быстро захватит блокировку и отработает, после чего будет вставать в очередь вместе со всеми, и вечного превосходства над другими потоками он не получит.
