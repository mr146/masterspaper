\section{Введение}

Я работаю разработчиком программного обеспечения в компании <<СКБ Контур>>, и наша команда занимается разработкой веб-сервиса для электронной отчетности в контролирующие органы. В периоды отчетности нагрузка на сервис растет по сравнению с межотчетными периодами, пик посещений достигается за день до конца отчетности и продолжается вплоть до ее окончания. Если наш продукт станет недоступным в последний день отчетности ~--- тысячи организаций не смогут отчитаться в регламентированный срок, что чревато большими штрафами от контролирующего органа и последующим оттоком клиентов из нашего сервиса. Поэтому сервис должен быть устойчив к высоким нагрузкам.

Отказ системы может произойти по разным причинам, например из-за сетевых неполадок или аварийного завершения работы одной из компонент. Например, если сервер, на котором запущен отвечающий за индексацию накладных сервис, пользователи потеряют доступ к своим данным до устранения проблемы. Эту проблему можно решить с помощью запуска сервиса на нескольких машинах: в таком случае если одна из них выйдет из строя, остальные смогут продолжить обработку запросов. Также данное решение может избавить нас от проблемы с недоступностью из-за сетевых неполадок: выпадание одной реплики сервиса из сети не остановит работу системы.

По тем же причинам необходимо использовать отказоустойчивую базу данных. По <<историческим>> причинам в нашем сервисе используется Cassandra от Apache: наш отдел к моменту начала разработки нового сервиса имел достаточно большой опыт в использовании и администрировании этого хранилища.

При разработке многопоточных приложений часто встает задача предоставления исключительного доступа к какому-либо разделяемому ресурсу. В большинстве современных языков программирования эта задача решается на уровне синтаксиса (конструкции lock в C\#, synchronized в Java), но только в рамках одного приложения на одной машине. В нашем же случае мы имеем дело с рапределенной системой, где нескольким компонентам может потребоваться доступ к одному и тому же ресурсу. Отсюда возникает задача распределенной блокировки ~--- необходим механизм, позволяющий решать проблему исключительного доступа к ресурсу из разных приложений.

Существует множество готовых решений данной задачи, одним из самых распространенных является Apache ZooKeeper. Однако этот инструмент обладает очень высоким порогом входа: более-менее удобный и надежный API для ZooKeeper есть только для Java (на котором он, собственно, и реализован), а реализация своей обертки ~--- очень трудоемкая задача. Более того, внедрение любого стороннего решения в проект связано с массой проблем, отнимающих достаточно большое количество времени. Администрирование, настройка, разворачивание ~--- на все это уйдет не один день даже достаточно опытного разработчика, если речь идет о новом решении, ранее не применявшемся в проекте.

В магистерской работе 2012 года Федора Фоминых задача о распределенной блокировке всплывает как подзадача при построении распределенной очереди на Cassandra. Однако в ходе использования предложенного алгоритма была отмечена достаточно важная проблема ~--- проседание производительности в случае попытки взятия одной и той же блокировки достаточно большим количеством потоков.

Была поставлена цель ~--- предложить и реализовать алгоритм, не имеющий проблемы со снижением производительности при любом количестве потоков. Цель была достигнута, на данный момент решение находится на стадии внедрения в проект.