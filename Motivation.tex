\section{Введение}

При разработке современного веб-сервиса необходимо уделять особое внимание его быстродействию и надежности, особенно когда речь идет о веб-сервисах, помогающих в ведении бизнеса (взаимодействие с банками, электронная отчетность и т.д.). Отказ подобных систем может повлечь финансовые потери клиента, а порой и поставить под угрозу весь его бизнес. Например, не вовремя или неверно сданная отчетность может повлечь серьезные штрафы со стороны государства, вплоть до отзыва лицензии.

Отказ системы может произойти по разным причинам, например, из-за сетевых неполадок или аварийного завершения работы одной из компонент. Например, если сервис, отвечающий за поиск по пользовательским данным, перестанет отвечать, то многие клиенты потеряют возможность полноценной работы в системе, поскольку лишатся возможности быстро находить нужную информацию. Эту проблему можно решить с помощью запуска сервиса на нескольких серверах: в таком случае если одна из его реплик выйдет из строя, остальные смогут продолжить обработку запросов. Также данное решение может избавить нас от проблем с недоступностью из-за сетевых неполадок: недоступность одной из реплик не остановит работу системы.

По тем же причинам необходимо использовать базу данных, поддерживающую запуск на нескольких серверах и толерантную к периодической недоступности одного или нескольких серверов. В зависимости от типов запросов, которые база данных должна уметь обрабатывать, и нагрузок, которые она должна выдерживать, можно выбрать одно из множества доступных решений: $MongoDB$\footnote{https://www.mongodb.org}, $Berkeley\;DB$\footnote{http://www.oracle.com/us/products/database/berkeley-db/} (а также любое другое NoSQL решение) или же взять обычный MySQL с master-slave репликацией.

При разработке многопоточных приложений часто встает задача предоставления исключительного доступа к какому-либо разделяемому ресурсу. Рассмотрим простой пример: снятие денег со счета с двух банкоматов. Предположим, что на счете лежит 200 условных единиц, и два пользователя хотят снять с этого счета по 150 единиц в один и тот же момент времени. Алгоритм снятия денег в первом приближении достаточно прост: узнать сколько денег на счете, и если средств достаточно, то выдать требуемую сумму и списать ее со счета. Если этот алгоритм будет выполняться одновременно двумя потоками без каких-либо блокировок, то может возникнуть следующая ситуация: оба потока одновременно запросят остаток на счете, поймут, что средств достаточно и каждый снимет со счета по 150 условных единиц, оставив на счете отрицательное значение, что в действительности неприемлемо. Если же перед началом выполнения мы можем сказать, что сейчас мы будем работать со счетом и никто другой этого делать не должен, то такой ситуации получиться не может.

Большинство современных языков программирования содержит механизмы, позволяющие решить эту задачу, но только в рамках одного процесса, в некоторых языках реализованы механизмы для решения этой задачи для разных процессов, запущенных на одном сервере. Однако, когда речь идет о процессах, запущенных на разных серверах, возникает задача распределенной блокировки~--- необходим механизм, позволяющий решать проблему исключительного доступа к ресурсу с разных серверов.

Существует множество готовых решений данной задачи. Существует $Chubby$\footnote{http://research.google.com/archive/chubby.html} от Google, но оно является проприетарным и его исходного кода нет в открытом доступе. Есть $Apache\;ZooKeeper$\footnote{https://zookeeper.apache.org}, это решение лежит в свободном доступе и активно развивается, но оно обладает достаточно высоким порогом входа: более или менее удобный и надежный клиент для ZooKeeper есть только для Java, а реализация своей обертки~--- очень трудоемкая задача. Можно решить задачу с использованием транзакционной базы данных (MySQL, MSSQL), но в некоторых случаях это решение будет иметь недостаточно высокую производительность.

В магистерской работе 2012 года Федора Фоминых задача о распределенной блокировке появляется как подзадача при построении распределенной очереди на базе данных $Apache\;Cassandra$\footnote{http://cassandra.apache.org}. Однако в ходе использования предложенного алгоритма была отмечена достаточно важная проблема~--- падение производительности в случае попытки взятия одной и той же блокировки достаточно большим количеством потоков.

В рамках работы была разработана новая версия алгоритма, не имеющая проблемы со снижением производительности при большом количестве потоков.
