\section{Обзор существующего решения}

Рассмотрим алгоритм, описанный в [1].

В качестве основы для реализаций стратегий блокировок предлагается алгоритм, который пытается взять блокировку и возвращает в качестве результата одно из трех состояний:

\begin{itemize}
	\item Success~--- поток успешно взял блокировку;
	\item AnotherThreadIsOwner~--- другой поток уже владеет блокировкой;
	\item ConcurrentAttempt~--- поток не смог взять блокировку, так как другой поток попытался сделать это одновременно с ним.
\end{itemize}

Заведем в Cassandra две таблицы~--- основную и теневую. В теневой таблице будет происходить борьба потоков за право взятия блокировки: поток будет записывать туда свой идентификатор и проверять, один ли он в таблице путем полного ее вычитывания, и если он действительно один, то блокировка будет считаться взятой. В основной таблице будет фиксироваться факт взятия блокировки тем или иным потоком путем записывания в таблицу идентификатора потока-владельца.
Сам алгоритм выглядит следующим образом:


\begin{lstlisting}[language=csh,caption={Алгоритм Cassandra.TryLock(lockId, threadId)}]
 1. |Взять ячейки из основной таблицы из строки lockId|
 2. |Если ячейка одна:|
 3. 	|Если columnKey = threadId:|
 4. 		|Вернуть Success|
 5. 	|Иначе:|
 6. 		|Вернуть AnotherThreadIsOwner|
 7. |Добавить ячейку в теневую таблицу|
 8. |Взять ячейки из теневой таблицы|
 9. |Если ячейка в теневой таблице одна|
10. 	|Если нет ячеек в основной таблице|
11. 		|Добавить ячейку в основную таблицу|
12. 		|Удалить свою ячейку из теневой таблицы|
13. 		|Вернуть Success|
14. |Удалить свою ячейку из теневой таблицы|
15. |Вернуть ConcurrentAttempt|
\end{lstlisting}

С использованием этого алгоритма достаточно просто реализовать алгоритм обязательной блокировки~--- просто будем запускать алгоритм\\ $Cassandra.TryLock$ до тех пор, пока блокировка не будет захвачена:

\begin{lstlisting}[language=csh,caption={Алгоритм Cassandra.GetLock(lockId, threadId)}]
 1. |Присвоить attempt = 1|
 2. |Вызвать Cassanrda.TryLock(lockId, threadId)|
 3. |Если Success:|
 4. 	|Закончить|
 5. |Если AnotherThreadIsOwner|
 6. 	|Подождать случайный промежуток времени от 0 до 1000 мс|
 7. 	|Перейти к 2|
 8. |Если ConcurrentAttempt:|
 9. 	|Подождать случайный промежуток времени от 0 до 50*attempt мс|
10. 	|Присвоить attempt = attempt + 1|
11. 	|Перейти к 2|
\end{lstlisting}

По факту потоки будут бороться друг с другом за право захвата блокировки, не пытаясь договориться друг с другом. Таким образом, с увеличением потоков увеличивается время, необходимое для взятия блокировки хотя бы одним потоком. Еще один недостаток этого алгоритма менее очевидный. Представим себе ситуацию, когда два потока последовательно много раз пытаются взять одну и ту же блокировку. Как только один из них сможет ее захватить, второй поток не сможет взять блокировку после первого же ее освобождения: возможно в момент отпускания блокировки первым потоком второй поток будет находиться в состоянии ожидания, в таком случае первый поток тут же этим воспользуется и захватит блокировку повторно. Таким образом второй поток не сможет захватить блокировку пока не выйдет из состояния ожидания в нужный момент. Это приводит к тому, что потоки будут выполнять свои действия неравномерно~--- сначала большую пачку действий выполнит первый поток, потом второй, затем первый вернет себе лидерство и так далее. В идеале же хотелось бы несколько более справедливый алгоритм, который не будет неявным образом отдавать предпочтение тому или иному потоку на протяжении долгого времени.