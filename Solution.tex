\section{Описание алгоритмов}

Желание получить алгоритм, справедливо распределяющий доступ к разделяемому ресурсу между потоками, подводит к достаточно простой идее использования некоторого подобия очереди потоков.
Для каждого идентификатора разделяемого ресурса будем хранить в Cassandra две строки: первую будем использовать в качестве подобия очереди (далее <<очередь>>), во второй будет храниться идентификатор потока, владеющего ресурсом (далее <<основная строка>>).
При добавлении потока в очередь мы будем добавлять новую ячейку в строчку с очередью, при этом имя колонки этой ячейки будет подсчитано следующим образом:

\begin{lstlisting}[language=csh,caption={Определение имени колонки для ячейки в очереди}]
 1. |Положить в переменную currentTime строковое значение текущего времени в микросекундах|
 2. |Добавлять к значению currentTime ведущие нули до тех пор, пока его длина не станет равной 20|
 3. |Назначить именем колонки конкатенацию значений currentTime и threadId|
\end{lstlisting}

В силу того, что ячейки в строке хранятся в лексикографическом порядке имен колонок, раньше всех в очереди окажется тот поток, который будет добавлен в очередь раньше, в случае равенства времен ближе к вершине очереди окажется поток с лексикографически меньшим идентификатором.
При добавлении потока в основную строку именем колонки будем считать просто идентификатор потока.

Все доказательства основываются на том предположении, что потоки будут поступать в очередь с неубывающим временем в качестве префикса имени колонки. Последнее предположение является достаточно грубым в условиях распределенной системы с множеством серверов, так как время на машинах может рассинхронизироваться в случае недобросовестного администрирования системы. Эта проблема была решена с помощью реализации сервиса времени.

\input StrongLock

\input WeakLock

\input ReleaseLock

\input TimeService

\input Implementation