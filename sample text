При разработке распределенных сервисов, компоненты которых могут находиться на разных серверах, следует уделять особое внимание доступу и изменениям данных, которые являются общими для различных компонент системы. Если в качестве базы данных выбрана любая транзакционная, например MySQL, то особых проблем возникать не должно. Однако если мы хотим использовать распределенную базу данных, в которых доступ и изменения данных проходят не в транзакции, проблема стоит особенно остро. Соответственно требуются механизмы синхронизации потоков. Большинство современных языков программирования поддерживают механизмы блокировок, но только в рамках одного процесса, что неприменимо в случае распределенной системы, где потоки могут работать в нескольких процессах, запущенных на разных серверах. Возникает протребность в реализации механизма распределенной блокировки.

Существуют готовые решения задачи распределенной блокировки. Блаблабла chubby, блаблабла zookeeper.
Нам не удалось найти доступное и достаточно быстро встраиваемое готовое решение, было решено разработать собственный механизм распределенных блокировок.

Три года назад был разработан и реализован алгоритм, позволяющий решить задачу распределенной блокировки с использованием базы данных Apache Cassandra. Apache Cassandra - отказоустойчивое распределенное NoSQL-хранилище, которое в первом приближении является разреженной таблицей. Алгоритм активно использовал свойства хранения данных в таблице, была доказана его корректность. Однако при детальном изучении его поведения были обнаружены два существенных недостатка, проявляющиеся при появлении какой-либо конкурентности в системе. Первый недостаток заключается в том, что при захвате несколькими потоками одной и той же блокировки несколько раз подряд алгоритм может отдавать блокировку одному и тому же потоку на протяжении долгого времени, и, как следствие, нагрузка на сервисы распределяется неравномерно. Второй недостаток заключается в том, что если несколько потоков хотят одновременно захватить одну и ту же блокировку, то они долгое время не смогут договориться, кто из них победит и захватит ее первым.

В итоге был разработан новый алгоритм, который лишен этих недостатков. Он также использует свойства хранения данных в таблицах Cassandra. При запросе на захват блокировки поток встает в общую очередь в определенной строке таблицы, а алгоритм отдает блокировку в порядке этой очереди.

Новый алгоритм был реализован на C#, покрыт модульными и нагрузочными тестами. Также был проведен ряд экспериментов по сравнению производительностей старого и нового алгоритма.

Первый эксперимент был устроен следующим образом: несколько процессов брали и отпускали одну и ту же блокировку несколько раз подряд, фиксировалось время ожидания освобождения блокировки и время, прошедшее с начала эксперимента до взятия очередной блокировки. На данном графике отражается поведение старого алгоритма при выполнении описанного сценария пятью процессами с 5000 блокировок, по оси х расположены номера очередного взятия блокировки, по оси у - время, прошедшее с начала эксперимента до момента взятия соответствующей блокировки. Видно, что времена взятия блокировок с одинаковым номером у разных процессов сильно отличаются. Также можно заметить, что в некоторых случаях взятия очередной блокировки приходится ждать очень долго.
Этот график аналогично показывает поведение нового алгоритма. Видно, что блокировки распределяются между процессами гораздо более равномерно, чем в случае старого алгоритма. Более того, время взятия последней блокировки меньше, чем у старого алгоритма.

Второй эксперимент был устроен иначе: сто раз пять потоков пытались захватить одну блокировку один раз, при этом фиксировалось время, ушедшее на захват блокировки. По оси х расположены номера очередной блокировки, по оси у - время, ушедшее на взятие блокировки. Синяя линия соответствует поведению старого алгоритма, красная - поведению нового алгоритма. Видно, что в большинстве случаев взятие блокировки старым алгоритмом занимает существенно больше времени, чем взятие новым.