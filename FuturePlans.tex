\section{Заключение}

\subsection{Проблемы подхода}

В ходе проектирования и реализации алгоритма был отмечен ряд проблем:

\begin{itemize}
	\item рассинхронизация времени на серверах;
	\item долгое отпускание блокировки в случае аварийного завершения работы потока-владельца;
	\item потеря связи с Cassandra в момент продления аренды.
\end{itemize}

Проблема с рассинхронизацией времени интересна в разрезе разных наборов серверов.

В случае рассинхронизации на серверах с репликами сервиса времени может возникнуть следующая ситуация: если реплика, время на которой сильно убежало вперед относительно других, выйдет из строя, то значение времени в Cassandra не будет обновляться до тех пор, пока реплика не возобновит свою работу или пока время на других репликах не станет больше значения, записанного в Cassandra. В такой ситуации сервис времени будет отдавать одно и то же значение времени на протяжении нескольких секунд или даже минут, что повлияет на работу алгоритмов блокировки: потоки будут вставать в случайное место в очереди, так как имена колонок ячеек, которые мы будем записывать в очередь, будут отличаться лишь идентификатором потока.

В случае рассинхронизации времени на серверах с репликами Cassandra ситуация более плачевна. В силу внутреннего устройства Cassandra, если время на репликах разъедется больше чем на время жизни ячейки, то ячейка будет тут же удаляться из строки, и корректность работы алгоритма блокировки будет нарушена. Поэтому время жизни ячейки приходится указывать достаточно большим, около 15 минут.

Для избавления от проблем с рассинхронизацией времени на серверах требуется детально разобраться в том, как не давать времени сильно убегать вперед относительно других серверов.

Проблема с долгим отпусканием блокировки заключается в следующем: если поток-владелец блокировки аварийно завершит работу, то освобождение блокировки произойдет только по истечении времени жизни ячеек в очереди и в основной строке, а это время может быть достаточно большим.

Проблема с потерей связи с Cassandra в момент продления аренды заключается в том, что разработанный алгоритм блокировки рассчитывает на стабильную и безотказную работу потока-арендатора блокировки. Однако возможна такая ситуация, что во время выполнения действий в блокировке связь с Cassandra может прерваться, из-за чего продление аренды может не сработать и блокировка освободится. Требуется придумать, как поток, отвечающий за продление аренды, сможет просигнализировать потоку, выполняющему действия в блокировке, что блокировку не удалось продлить и, возможно, она уже захвачена другим потоком.

\subsection{Внедрение в проект}

Описанные выше проблемы не являются критичными для проекта, в который решение внедряется в данный момент, по следующим причинам: 

\begin{itemize}
	\item Использование Cassandra в проекте обязывает нас следить за тем, чтобы время сильно не рассинхронизировалось. В нашем проекте проблемами рассинхронизации времени на серверах занимается отдел СПС\footnote{Служба поддержки серверов}. В данный момент есть гарантия того, разница времен на серверах не превысит 5 минут. Ведутся работы для уменьшения этого числа.

	\item Аварийное завершение работы потока-владельца происходит достаточно редко, и в этих случаях мы готовы к тому, что остальным потокам придется подождать некоторое время.

	\item Возможная потеря связи с Cassandra в момент очередной попытки продлить аренду также не является критичной проблемой, так как все общие для процессов данные хранятся в том же кластере Cassandra, который используется алгоритмом блокировки. Поэтому если связь с Cassandra будет прервана, то во время выполнения действий в блокировке мы не сможем поменять состояние данных в Cassandra. 
\end{itemize}

Однако внедрение нового решения осложняется тем, что необходимо провести плавный переход со старого алгоритма на новый без остановки сервисов. Для этого на время перехода будет работать комбинированный алгоритм, который будет брать блокировку с использованием нового алгоритма, при этом учитывая, что часть блокировок могла быть захвачена с помощью старого.
