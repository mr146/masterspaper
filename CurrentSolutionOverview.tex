\section{Обзор существующего решения}

Рассмотрим алгоритм, описанный в [ссылка].

Заведем в Cassandra 2 таблицы: основную и теневую. В качестве основы для реализаций стратегий блокировок предлагается алгоритм, который пытается взять блокировку и возвращает в качестве результата одно из трех состояний:

\begin{itemize}
	\item Success~--- поток успешно взял блокировку;
	\item AnotherThreadIsOwner~--- другой поток уже владеет блокировкой;
	\item ConcurrentAttempt~--- поток не смог взять блокировку, так как другой поток попытался сделать это одновременно с ним.
\end{itemize}

Сам алгоритм выглядит следующим образом:

[Тут будет описание алгоритма строка-в-строку]

С использованием этого алгоритма достаточно просто реализовать, например, стратегию обязательной блокировки:

\begin{itemize}
	\item Тут будет описание алгоритма обязательной блокировки
\end{itemize}

По факту потоки будут бороться друг с другом за право захвата блокировки, не пытаясь договориться друг с другом. Теоретически при большом количестве потоков может сложиться такая ситуация, что потоки могут долгое время пытаться оказаться одни в теневой таблице, то есть время взятия блокировки хотя бы одним потоком становится непредсказуемым. Еще один недостаток этого алгоритма более неочевидный. Представим себе ситуацию, когда два потока последовательно много раз пытаются взять одну и ту же блокировку. Как только один из них сможет ее захватить, второй поток не сможет взять блокировку после первого же ее освобождения: возможно в момент отпускания блокировки первым потоком второй поток будет находиться в состоянии ожидания, в таком случае первый поток тут же этим воспользуется и захватит блокировку повторно. Таким образом второй поток не сможет захватить блокировку пока не выйдет из состояния ожидания в нужный момент. Это приводит к тому, что потоки будут выполнять свои действия неравномерно~--- сначала большую пачку действий выполнит первый потом, потом второй, потом первый вернет себе лидерство и так далее. В идеале же хотелось бы несколько более справедливый алгоритм, который не будет неявным образом отдавать предпочтение тому или иному потоку на протяжении долгого времени.