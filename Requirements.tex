\section{Требования к интерфейсу сервиса распределенной блокировки}

Сформулируем требования к интерфейсу сервиса распределенной блокировки. Фактически необходимо реализовать два стратегии блокировки:

\begin{itemize} 
	\item Обязательная блокировка~--- подразумевает, что блокировка будет взята в любом случае: поток в любом случае дождется освобождения нужного ресурса и обязательно возьмет блокировку;
	\item Мягкая блокировка~--- подразумевает, что блокировка может быть и не взята: поток попытается взять блокировку, но если ресурс уже занят другим потоком, он продолжит свое выполнение.
\end{itemize}

Разница достаточно проста и прозрачна~--- первая стратегия применяется в случае когда оба потока обязательно должны совершить свое действие (например, вывести сообщение на консоль или в лог), вторая же применима если нам достаточно чтобы хотя бы один поток совершил свое действие (например, взял конкретную запись из некоторого хранилища и обработал ее). 

Опишем данные требования на языке C\#:

\begin{lstlisting}[language=csh,caption={Описание интерфейса}]
public interface IRemoteLockCreator
{
	IRemoteLock GetLock(string lockId); // обязательная блокировка
	bool TryGetLock(string lockId, out IRemoteLock remoteLock); // мягкая блокировка
}

public interface IRemoteLock : IDisposable
{
	public string ThreadId { get; }
	public string LockId { get; }
}
\end{lstlisting}

Здесь lockId~--- строковый идентификатор ресурса, доступ к которому необходимо получить. Метод Dispose в реализацях интерфейса IRemoteLock должен освобождать блокировку, в таком случае пользоваться сервисом блокировок будет достаточно удобно с помощью конструкции using:

\begin{lstlisting}[language=csh,caption={Использование конструкции using}]
	...
	using(remoteLockCreator.GetLock(lockId))
	{
		// действия в блокировке
	}
\end{lstlisting}