\section{Описание алгоритмов}

Желание получить алгоритм, справедливо распределящий доступ к разделяемому ресурсу между потоками, подводит к достаточно простой идее использования некоторого подобия очереди потоков.
Для каждого идентификатора разделяемого ресурса будем хранить в Cassandra две строки: первую будем использовать в качестве подобия очереди (далее <<очередь>>), во второй будет храниться идентификатор потока, владеющего ресурсом (далее <<основная строка>>).
При добавлении потока в очередь мы будем добавлять новую ячейку в строчку с очередью, при этом имя колонки этой ячейки будет подсчитано следующим образом:

\begin{lstlisting}[language=csh,caption={Определение имени колонки для ячейки в очереди}]
 1. |Положить в переменную currentTime строковое значение текущего времени в микросекундах|
 2. |Добавлять к значению currentTime ведущие нули до тех пор, пока его длина не станет равной 20|
 3. |Назначить именем колонки конкатенацию значений currentTime и threadId|
\end{lstlisting}

В силу свойства порядка хранения ячеек в строке раньше всех в очереди окажется тот поток, который будет добавлен в очередь раньше, в случае равенства времен ближе к вершине очереди окажется поток с лексикографически меньшим идентификатором.
При добавлении потока в основную строку именем колонки будем считать просто идентификатор потока.

Описанные алгоритмы реализуют лишь захват блокировки, ее освобождение будет изложено далее.
Также все доказательства основываются на том предположении, что потоки будут поступать в очередь с неубывающим временем в качестве префикса имени колонки. Последее предположение является достаточно грубым в условиях распределенной системы с множеством серверов, так как время на машинах может <<разъезжаться>> без должного администрирования с точки зрения NTP, впрочем решение этого вопроса также будет освещено далее в работе.

\input StrongLock

\input WeakLock