\section{Введение}

При разработке современного веб-сервиса необходимо уделять особое внимание его быстродействию и надежности, особенно когда речь идет о веб-сервисах, помогающих в ведении бизнеса (взаимодействие с банками, электронная отчетность и т.д.). Отказ подобных систем может повлечь финансовые потери клиента, а порой и поставить под угрозу весь его бизнес. Например, невовремя или неверно сданная отчетность может повлечь серьезные штрафы со стороны государства, вплоть до отзыва лицензии.

Отказ системы может произойти по разным причинам, например из-за сетевых неполадок или аварийного завершения работы одной из компонент. Например, если сервис, отвечающий за поиск по пользовательским данным, перестанет отвечать, то многие клиенты потеряют возможность полноценной работы в системе, поскольку лишатся возможности быстро находить нужную информацию. Эту проблему можно решить с помощью запуска сервиса на нескольких машинах: в таком случае если одна из реплик сервиса выйдет из строя, остальные смогут продолжить обработку запросов. Также данное решение может избавить нас от проблем с недоступностью из-за сетевых неполадок: выпадение одной реплики сервиса из сети не остановит работу системы.

По тем же причинам необходимо использовать отказоустойчивую базу данных. В зависимости от типов запросов, которые база данных должна уметь обрабатывать, и нагрузок, которые она должна выдерживать, можно выбрать одно из множества доступных решений: MongoDB, Berkeley DB (а также любое другое NoSQL решение) или же взять обычный MySQL с master-slave репликацией.

При разработке многопоточных приложений часто встает задача предоставления исключительного доступа к какому-либо разделяемому ресурсу. Рассмотрим простой пример: снятие денег со счета с двух банкоматов. Предположим, что на счете лежит 200 условных единиц, и два пользователя хотят снять с этого счета по 150 единиц в один и тот же момент времени. Алгоритм снятия денег в первом приближении достаточно прост: узнать сколько денег на счете, и если средств достаточно, то выдать требуемую сумму и списать ее со счета. Если этот алгоритм будет выполняться одновременно двумя потоками без каких-либо блокировок, то может возникнуть следующая ситуация: оба потока одновременно запросят остаток на счете, поймут что средств достаточно и каждый снимет со счета по 150 условных единиц, оставив на счете отрицательное значение, что в действительности неприемлимо. Если же перед началом выполнения мы можем сказать, что сейчас мы будем работать со счетом и никто другой этого делать не должен, то такой ситуации получиться не может.

Большинство современных языков программирования содержит механизмы, позволяющие решить эту задачу, но только в рамках одного процесса, в некоторых языках реализованы механизмы для решения этой задачи для разных процессов, запущенных на одном сервере. Однако когда речь идет о процессах, запущенных на разных серверах, возникает задача распределенной блокировки~--- необходим механизм, позволяющий решать проблему исключительного доступа к ресурсу с разных серверов.

Существует множество готовых решений данной задачи. Существует Chubby от Google, но оно является проприетарным и его исходного кода нет в открытом доступе. Есть Apache ZooKeeper, это решение лежит в свободном доступе и активно развивается, но оно обладает достаточно высоким порогом входа: более-менее удобный и надежный клиент для ZooKeeper есть только для Java, а реализация своей обертки~--- очень трудоемкая задача. Можно воспользоваться ресурсами любой централизованной базы данных с транзакциями (MySQL, MSSQL), но в некоторых случаях это решение будет недостаточно высокую производительность.

В магистерской работе 2012 года Федора Фоминых задача о распределенной блокировке появляется как подзадача при построении распределенной очереди на Cassandra (NoSQL база данных, которая активно используется у нас в проекте). Однако в ходе использования предложенного алгоритма была отмечена достаточно важная проблема~--- проседание производительности в случае попытки взятия одной и той же блокировки достаточно большим количеством потоков.

В рамках работы была разработана новая версия алгоритма, не имеющая проблемы со снижением производительности при большом количестве потоков. Исходный код проекта доступен по адресу http://git.skbkontur.ru, также в работе содержатся результаты нагрузочного тестирования алгоритма.