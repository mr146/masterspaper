\subsection{Аренда и освобождение блокировки}

Алгоритмы Cassandra.GetLock и Cassandra.TryGetLock позволяют захватить блокировку, при этом в результате захвата блокировки в очереди и в основной строке остаются колонки, порожденные потоком. Для освобождения блокировки достаточно удалить эти колонки из строчек. Эту логику достаточно поместить в метод Dispose у реализации интерфейса IRemoteLock, в таком случае при использовании конструкции using в конце исполнения кода внутри блокировки разделяемый ресурс освободится.

Однако давайте представим себе следующую ситуацию: поток успешно взял блокировку, после чего аварийно завершил свою работу таким образом, что метод Dispose не отработал. В итоге система находится в таком состоянии, что ни один поток не сможет взять блокировку на этот ресурс, и освободить его тоже никто не сможет, то есть блокировка захвачена навечно.

Можно решить эту проблему достаточно просто с использованием Cassanrda: при записи ячеек в очередь и в основную таблицу будем выставлять для этих ячеек TTL в размере N секунд, а в случае успешного взятия блокировки создадим дополнительный фоновый поток, который раз в N/2 секунд будет перезаписывать ячейки в строчках. Таким образом в случае аварийного завершения процесса, поток которого захватил блокировку и не успел ее освободить, ячейки исчезнут из таблицы, так как вместе с потоком, удерживающим блокировку, прекратит свою работу и поток, отвечающий за продление аренды.

Таким образом при успешном взятии блокировки нам необходимо создать фоновый поток, который будет время от времени перезаписывать существующие ячейки в строчках, а при освобождении блокировки нужно будет остановить этот фоновый поток и удалить записаные ячейки из очереди и из основной строки.