\subsection{Алгоритм обязательной блокировки}

Алгоритм обязательной блокировки устроен следующим образом: поток ставит себя в очередь на блокировку, ждет пока он окажется первым в очереди и записывает себя в основную строку. Если после этого в основной строке оказалась одна ячейка, то блокировка считается взятой, в противном случае поток удалит записанную ячейку из основной строки и повторит итерацию еще раз.

\begin{lstlisting}[language=csh,caption={Алгоритм Cassandra.GetLock(lockId, threadId)}]
  1.  |Добавить поток в очередь|
  2.  |Если наш поток - первый в очереди:|
  3.  	|Добавить ячейку в основную строку|
  4.  	|Если в основной строке есть только одна запись:|
  5.  		|Закончить|
  6.  	|Иначе:|
  7.  		|Удалить ячейку из основной строки|
  8.  		|Перейти к шагу 2|
  9.  |Иначе:|
 10.  	|Перейти к шагу 2|

\end{lstlisting}

\begin{lemma}
Если два потока A и B одновременно запишут по одной ячейке в одну строку в Cassandra и после этого прочитают ее, то хотя бы один из них увидит в строке обе записи.
\end{lemma}
\textbf{Доказательство:}
Предположим, что это не так, и каждый из поток прочитал строчку, в которой смог найти лишь свою запись. Из консистентности Cassandra следует, что если поток A не смог увидеть запись потока B, то поток B еще не успел записать свою ячейку, то есть A сделал запись строго раньше B. Но поток B также не увидел запись потока A, следовательно B сделал запись строго раньше A. Получено противоречие, следовательно хотя бы один из потоков увидит обе записи.
$\Box$

\begin{theorem}
В ходе выполнения алгоритма Cassandra.GetLock несколькими потоками блокировка не будет взята более чем одним потоком одновременно.
\end{theorem}
\textbf{Доказательство:}
Предположим, что два потока одновременно смогли взять блокировку. Это означает, что они оба записались в одну и ту же строку, и после ее прочтения каждый из них увидел лишь одну запись, что противоречит лемме 1. Следовательно, блокировку может быть взята лишь одним из них.
$\Box$