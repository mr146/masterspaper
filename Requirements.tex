\section{Требования к интерфейсу сервиса распределенной блокировки}

Сформулируем требования к интерфейсу сервиса распределенной блокировки. Фактически необходимо реализовать две стратегии блокировки:

\begin{itemize} 
	\item обязательная блокировка~--- подразумевает, что блокировка будет взята в любом случае: поток в любом случае дождется освобождения нужного ресурса и обязательно возьмет блокировку;
	\item мягкая блокировка~--- подразумевает, что блокировка может быть и не взята: поток попытается взять блокировку, но, если ресурс уже занят другим потоком, во взятии блокировки будет отказано, после чего поток сможет сам решить, как ему обработать эту ситуацию.
\end{itemize}

Разница достаточно проста и прозрачна~--- первая стратегия применяется в случае, когда оба потока обязательно должны совершить свое действие (например, снять деньги со счета пользователя), вторая же применима, если нам достаточно, чтобы хотя бы один из потоков совершил свое действие (например, отправить SMS-уведомление пользователю). 

Опишем данные требования на языке C\#:

\begin{lstlisting}[language=csh,caption={Описание интерфейса}]
public interface IRemoteLocker
{
	IRemoteLock GetLock(string lockId); // обязательная блокировка
	bool TryGetLock(string lockId, out IRemoteLock remoteLock); // мягкая блокировка
}

public interface IRemoteLock : IDisposable
{
	public string ThreadId { get; } // идентификатор потока
	public string LockId { get; } // идентификатор ресурса
}
\end{lstlisting}

Здесь $lockId$~--- строковый идентификатор ресурса, доступ к которому необходимо получить. Метод $Dispose$ в реализациях интерфейса $IRemoteLock$ должен освобождать блокировку, в таком случае пользоваться сервисом блокировок будет достаточно удобно с помощью конструкции $using$:

\begin{lstlisting}[language=csh,caption={Использование конструкции using}]
	...
	using(remoteLocker.GetLock(lockId))
	{
		// действия в блокировке
	}
\end{lstlisting}
