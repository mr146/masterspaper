\subsection{Алгоритм обязательной блокировки}

Алгоритм обязательной блокировки устроен следующим образом: поток ставит себя в очередь на блокировку, ждет пока он окажется первым в очереди и записывает себя в основную строку. Если после этого в основной строке оказалась одна ячейка, то блокировка считается взятой, в противном случае поток удалит записанную ячейку из основной строки и повторит итерацию еще раз.

\begin{lstlisting}[language=csh,caption={Алгоритм Cassandra.GetLock(lockId, threadId)}]
  1.  |Добавить поток в очередь|
  2.  |Если наш поток - первый в очереди:|
  3.  	|Добавить ячейку в основную строку|
  4.  	|Если в основной строке есть только одна запись:|
  5.  		|Закончить|
  6.  	|Иначе:|
  7.  		|Удалить свою ячейку из основной строки|
  8.  		|Перейти к шагу 2|
  9.  |Иначе:|
 10.  	|Перейти к шагу 2|

\end{lstlisting}

\begin{lemma}
Если два потока A и B одновременно запишут по одной ячейке в одну строку в Cassandra и после этого прочитают ее, то хотя бы один из них увидит в строке обе записи.
\end{lemma}
\textbf{Доказательство:}
Предположим, что это не так, и каждый из потоков прочитал строчку, в которой смог найти лишь свою запись. Из консистентности Cassandra следует, что если поток $A$ не смог увидеть запись потока $B$, то поток $B$ еще не успел записать свою ячейку, то есть $A$ сделал запись строго раньше $B$. Но поток $B$ также не увидел запись потока $A$, следовательно, $B$ сделал запись строго раньше $A$. Получено противоречие, следовательно, хотя бы один из потоков увидит обе записи.
$\Box$

\begin{theorem}
В ходе выполнения алгоритма Cassandra.GetLock несколькими потоками блокировка не будет взята более чем одним потоком одновременно.
\end{theorem}
\textbf{Доказательство:}
Предположим, что два потока одновременно смогли взять блокировку. Это означает, что они оба записались в одну и ту же строку, и после ее прочтения каждый из них увидел лишь одну запись, что противоречит лемме 1. Следовательно, блокировку может быть взята лишь одним из них.
$\Box$

\begin{theorem}
Если каждый поток будет завершать действие в блокировке за конечное время, то в ходе выполнения алгоритма Cassandra.GetLock несколькими потоками каждый поток получит блокировку за конечное время.
\end{theorem}
\textbf{Доказательство:}
При попытке захватить блокировку описанным алгоритмом поток в самом начале запишется в очередь и не удалится из нее до тех пор, пока блокировка не будет захвачена. Если поток в некоторый момент времени окажется первым в очереди и в очередь никто не сможет записаться перед этим потоком, то блокировка будет захвачена, как только текущий владелец ее освободит, а остальные потоки увидят, что они не первые в очереди. Освобождение блокировки текущим владельцем произойдет сразу после завершения его действий в блокировке, то есть за конечное время. Остальные потоки поймут, что они не первые в очереди, в момент очередного исполнения строки 2, то есть тоже за конечное время.
Осталось показать, что поток окажется первым в очереди за конечное время.
Предположим, что это неправда, и поток никогда не окажется в очереди первым. Это означает, что перед этим потоком в любой момент времени найдется хотя бы один поток, следовательно, потоки будут постоянно записываться с меньшей или равной временной отметкой, чем у данного потока. Однако это противоречит неубыванию времени в системе. Следовательно, поток окажется первым в очереди за конечное время.
$\Box$
