\section{Обзор существующего решения}

Рассмотрим алгоритм, описанный в [ссылка].

Заведем в Cassandra 2 таблицы: основную и теневую. В качестве основы для реализаций стратегий блокировок предлагается алгоритм, который пытается взять блокировку и возвращает в качестве результата одно из трех состояний:

\begin{itemize}
	\item Success~--- поток успешно взял блокировку;
	\item AnotherThreadIsOwner~--- другой поток уже владеет блокировкой;
	\item ConcurrentAttempt~--- поток не смог взять блокировку, так как другой поток попытался сделать это одновременно с ним.
\end{itemize}

Сам алгоритм выглядит следующим образом:


\begin{lstlisting}[language=csh,caption={Алгоритм Cassandra.TryLock(lockId, threadId)}]
 1. |Взять ячейки из основной таблицы из строки lockId|
 2. |Если ячейка одна:|
 3. 	|Если columnKey = threadId:|
 4. 		|Вернуть Success|
 5. 	|Иначе:|
 6. 		|Вернуть AnotherThreadIsOwner|
 7. |Добавить ячейку в теневую таблицу|
 8. |Взять ячейки из теневой таблицы|
 9. |Если ячейка в теневой таблице одна|
10. 	|Если нет ячеек в основной таблице|
11. 		|Добавить ячейку в основную таблицу|
12. 		|Удалить ячейку из теневой таблицы|
13. 		|Вернуть Success|
14. |Удалить ячейку из теневой таблицы|
15. |Вернуть ConcurrentAttempt|
\end{lstlisting}

С использованием этого алгоритма достаточно просто реализовать, например, стратегию обязательной блокировки:

\begin{lstlisting}[language=csh,caption={Алгоритм Cassandra.GetLock(lockId, threadId)}]
 1. |Присвоить attempt = 1|
 2. |Вызвать Cassanrda.TryLock(lockId, threadId)|
 3. |Если Success:|
 4. 	|Закончить|
 5. |Если AnotherThreadIsOwner|
 6. 	|Подождать случайный промежуток времени от 0 до 1000 мс|
 7. 	|Перейти к 2|
 8. |Если ConcurrentAttempt:|
 9. 	|Подождать случайный промежуток времени от 0 до 50*attempt мс|
10. 	|Присвоить attempt = attempt + 1|
11. 	|Перейти к 2|
\end{lstlisting}

По факту потоки будут бороться друг с другом за право захвата блокировки, не пытаясь договориться друг с другом. Теоретически при большом количестве потоков может сложиться такая ситуация, что потоки могут долгое время пытаться оказаться одни в теневой таблице, то есть время взятия блокировки хотя бы одним потоком становится непредсказуемым. Еще один недостаток этого алгоритма менее очевидный. Представим себе ситуацию, когда два потока последовательно много раз пытаются взять одну и ту же блокировку. Как только один из них сможет ее захватить, второй поток не сможет взять блокировку после первого же ее освобождения: возможно в момент отпускания блокировки первым потоком второй поток будет находиться в состоянии ожидания, в таком случае первый поток тут же этим воспользуется и захватит блокировку повторно. Таким образом второй поток не сможет захватить блокировку пока не выйдет из состояния ожидания в нужный момент. Это приводит к тому, что потоки будут выполнять свои действия неравномерно~--- сначала большую пачку действий выполнит первый потом, потом второй, потом первый вернет себе лидерство и так далее. В идеале же хотелось бы несколько более справедливый алгоритм, который не будет неявным образом отдавать предпочтение тому или иному потоку на протяжении долгого времени.